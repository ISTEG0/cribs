(создав файл .gitignore можно добавлять названия файлов в него, которые не нужны для отслеживания
в git)
git init |   - инициализирует файлы
git status | - проверить состояние файлов
git add . | - добавляет все файлы под контроль
git add <name file> | - добавляет выбранный файл под контроль
git commit -m "name comment" | - создание коммита с указанием кратеого комментария
git commit | - коммит с открытием редактора для подробного описания коммита.
git add -p <name file> | - позволяет в рамках одного файла опеределить какой фрагмент изменений
добавить под контрроль, а какой нет. (буквально по строчно)
git commit -am "name comment" | - позволяет одной командой проиндексировать файл и создать коммит
(примечание: дання команда работает только для тех файлов, которые уже были индексированы до этого)
git commit -m "name comment" (путь к файлу) | - сделает коммит к указанному файлу, также если он уже был
проиндексирован. (например: git commit -m "name comment" .gitignore)
git rm (путь к файлу) | - удаление с дерриктории и index, или с указанием дерриктории (строчка ниже)
git rm -r src | (src - в качестве примера) - эта каманда одновременно удаляет файл и добавляет в index.
git rm | - это как в два шага: 1) удалить файл 2) git add .
git rm -r --cached src | - удалить из индекса, но оставит в рабочем каталоге.(тоесть git перестал отслеживать), чтобы
обратно попало в index: git add src.
git rm --cached main.js | - тоже самое что и команда выше, убирает из под слежения гита.
git rm -f <name file> | - удалить файл из индекса и дерриктории, игнорируя предупреждения, о том, что файл не был 
сохранен в репозиторий.
git mv index.html hello.html | - одномременно переименует файл с первого на второй и добавит изменения в index.
Если переименовывать файлы в ручную, git посчитает это как удаление старого и добавление нового файла,
после переименовывания нужно сделать git add и тогда git поймет, что было переименовывание.
git branch | - показывает список веток
git branch -m (name) | - переименовать имя ветки, в реали без скобок писать. 
git branch -v | - показывает текущую ветку и коммит на который она указывает.
git branch <name new branch> | - создаст новую ветку.
git checkout <name branch> | - переключение на указанную ветку.
git checkout -b <name new branch> | - одновременно создаст ветку и сразу на нее переключится.
git checkout -f master | - переклчится с текущей ветки на ветку мастер, не оставляя созданных тзменений в
текущей ветки, если не были сделаны коммиты.
git checkout -f | - удалит все изменения в текущей ветке, которые не были закомичены (можно исмпользовать для 
эксперементов).
git stash | - собирает не закомиченные изменения, удаляет их из файла, и убирает в специальный архив.
Все изменения при git stash не привязвнны ни к какой ветке.
git stash pop | - вернет удаленные и архивированне изменения обратно, желательно git stash и git stash pop
делать в том же самом файле, чтобы не было конфликтов.
git checkout 54a4 index.html |- (если мы решили в текущей ветке текущего файла внести изменения старого коммита, то указыв-
ваем данной командой точный коммит и файл, который хотим изменить в текущей ветке текущего файла).
git checkout HEAD index.html | - если уже закомители - вернет изменения данного файла к исходному.
git checkout index.html | - ворачиваеет файл из index с текущеми изменениями.
git clone git@bitbucket.org:designclub/dubroshcha.git -b | - имя ветки - клонирование репозитория с указанием конкретной ветки.
git log | - список коммитов.
git checkout 035a128d2e66eb9fe3032036b3415e60c728f692 | - переключились на коммит.
git merge <название ветки> | - слияние текущей ветки  с указанной.
git reset --hard HEAD | - отмены всех локальных изменений и возврата рабочего дерева в состояние последнего коммита.
git stash | - поместят текущие изменения в "корзину" stash
git stash pop | - восстановят изменения из  "корзины" stash.

Пример:
	1) git stash
	2) git checkout <название_ветки>
	3) git stash pop

Эти команды (из прмиера выше) поместят текущие изменения в "корзину" stash, переключат вас на другую ветку, а затем восстановят изменения из stash.

git switch - | Для возвращения в предыдущую ветку (со сбросом всех изменений) используйте команду из состояния detached HEAD.
git switch -c | - <имя-новой-ветки> - создать новую ветку из этой точки состояния detached HEAD.

Что такое detached HEAD (отсоединенный указатель HEAD)?
В результате перехода к конкретному коммиту вы указываетесь в «состоянии отсоединенного указателя HEAD» («detached HEAD state»).

Из документации:

[a detached HEAD state] означает, что HEAD направлен на конкретный коммит, а не на именованную ветку.

В общем, HEAD (один из внутренних указателей Git, отслеживающий, где именно в истории Git вы находитесь) отклонился от известных веток, так что все изменения с этого момента будут формировать новый путь в истории Git. Поэтому Git хочет убедиться, что вы именно этого хотите, и в выводе предлагает вам пространство для экспериментов:

«Вы в состоянии detached HEAD. Можете осмотреться, внести какие-нибудь экспериментальные изменения и закоммитить их. Если затем вы переключитесь обратно на ветку, вы сбросите все коммиты, сделанные в этом состоянии, никак не задев никакие ветки».

Исходя из этого, у вас есть два варианта:

поэкспериментировать, а затем сбросить все изменения, вернувшись в предыдущую ветку
продолжить работу с этого места и начать новую ветку из этой точки.
Для возвращения в предыдущую ветку (со сбросом всех изменений) используйте команду git switch -.

Если вы все же хотите сохранить свои изменения, внесенные в состоянии detached HEAD, и продолжить работу с этого места, можете использовать git switch -c <имя-новой-ветки>, чтобы создать новую ветку из этой точки.

git remote add <имя удаленного репозитория, напрмер origin или свое> <url_репозитория> | - добавление еще одного удаленного репозитория к локальному
git remote set-url origin https://gitflic.ru/project/dcmedia/anvikor-ru.git | - поменять репозиторий origin (основной на другой)
git remote rm <имя_удаленного_репозитория, например origin>| - удалить удаленный репозиторий
